<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz: Revisão de Banco de Dados II</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 md:p-10 w-full max-w-3xl">
        
        <!-- Cabeçalho do Quiz -->
        <div id="quiz-header">
            <h1 class="text-3xl font-bold text-center text-indigo-600">Revisão de Banco de Dados II</h1>
            <p class="text-center text-gray-500 mt-2">Teste seus conhecimentos sobre Funções, Procedures, Triggers e Views.</p>
            <hr class="my-6">
        </div>

        <!-- Container do Quiz -->
        <div id="quiz-container">
            <!-- As perguntas serão injetadas aqui pelo JavaScript -->
        </div>

        <!-- Botão de Submissão -->
        <div id="submit-section" class="mt-8 text-center">
            <button id="submit-btn" class="w-full sm:w-auto bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-300 transform hover:scale-105">
                Verificar Respostas
            </button>
        </div>

        <!-- Container de Resultados -->
        <div id="results-container" class="hidden">
            <h2 class="text-2xl font-bold text-center text-gray-800">Seu Resultado</h2>
            <div id="score" class="text-4xl font-extrabold text-center my-4"></div>
            <div id="summary" class="text-lg text-center text-gray-600 mb-6"></div>
            
            <div id="detailed-results" class="mt-8 space-y-6">
                <!-- Os resultados detalhados serão injetados aqui -->
            </div>

            <div class="mt-10 text-center">
                <button id="retry-btn" class="w-full sm:w-auto bg-gray-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all duration-300 transform hover:scale-105">
                    Tentar Novamente
                </button>
            </div>
        </div>

    </div>

    <script>
        const quizData = [
            {
                question: "Qual é a principal característica que diferencia uma Função Armazenada (Stored Function) de um Procedimento Armazenado (Stored Procedure) em SQL?",
                options: [
                    "Funções podem executar instruções DML (INSERT, UPDATE, DELETE), enquanto procedimentos não podem.",
                    "Uma função deve obrigatoriamente retornar um único valor, enquanto um procedimento não precisa retornar valores.",
                    "Procedimentos são executados com o comando `EXECUTE`, enquanto funções são chamadas com o comando `CALL`.",
                    "Não há diferença, os termos são usados de forma intercambiável."
                ],
                correctAnswer: 1,
                rationale: "A distinção fundamental é que uma função é projetada para retornar um único valor e ser usada em expressões SQL (como em um SELECT ou WHERE), enquanto um procedimento é uma unidade de código para executar uma tarefa, podendo ou não retornar valores (geralmente via parâmetros OUT)."
            },
            {
                question: "O que é uma View em um banco de dados?",
                options: [
                    "Uma tabela física que armazena uma cópia dos dados de outra tabela para otimizar consultas.",
                    "Um tipo especial de trigger que é ativado quando uma tabela é criada.",
                    "Uma consulta `SELECT` armazenada que se comporta como uma tabela virtual.",
                    "Um índice que melhora a velocidade das operações de escrita (INSERT, UPDATE) em uma tabela."
                ],
                correctAnswer: 2,
                rationale: "Uma View é exatamente isso: uma tabela virtual baseada no resultado de uma instrução SELECT. Ela não armazena dados próprios, mas sim apresenta dados de tabelas subjacentes de uma forma específica, servindo para simplificar consultas e aplicar camadas de segurança."
            },
            {
                question: "Um Trigger de banco de dados pode ser configurado para ser disparado em qual momento em relação ao evento (INSERT, UPDATE, DELETE)?",
                options: [
                    "Apenas ANTES (BEFORE) do evento ocorrer.",
                    "Apenas DEPOIS (AFTER) que o evento foi concluído.",
                    "ANTES (BEFORE) ou DEPOIS (AFTER) do evento.",
                    "DURANTE (INSTEAD OF) o evento, mas apenas para tabelas."
                ],
                correctAnswer: 2,
                rationale: "Triggers podem ser acionados tanto ANTES (BEFORE) da operação DML ser executada (útil para validações) quanto DEPOIS (AFTER) dela ser concluída (útil para auditoria ou ações em cascata)."
            },
            {
                question: "Qual é a principal finalidade de um Procedimento Armazenado (Stored Procedure)?",
                options: [
                    "Apenas para retornar um valor escalar a ser usado em uma cláusula `WHERE`.",
                    "Encapsular uma lógica de negócio complexa que pode ser executada como uma única unidade.",
                    "Garantir que os dados em duas tabelas relacionadas sejam sempre consistentes.",
                    "Criar uma representação virtual de dados sem armazená-los fisicamente."
                ],
                correctAnswer: 1,
                rationale: "A grande vantagem dos procedimentos é agrupar uma sequência de comandos SQL e lógica de programação em um único bloco reutilizável, que pode ser chamado para executar uma tarefa completa, como 'processar_pedido'."
            },
            {
                question: "Em que situação o uso de um Trigger é mais apropriado?",
                options: [
                    "Para executar uma tarefa agendada, como gerar um relatório diário.",
                    "Para realizar uma consulta complexa que une várias tabelas de forma simplificada.",
                    "Para criar um log de auditoria automático sempre que um registro em uma tabela de funcionários for alterado.",
                    "Para calcular um valor complexo e retorná-lo para ser usado em uma instrução `SELECT`."
                ],
                correctAnswer: 2,
                rationale: "Triggers são ideais para ações que devem ocorrer automaticamente em resposta a modificações nos dados (DML). Criar um registro de auditoria é um caso de uso clássico, pois a ação acontece de forma implícita e garantida sempre que há uma alteração."
            },
            {
                question: "Qual das seguintes afirmações sobre a atualização de dados através de uma View é a mais precisa?",
                options: [
                    "Quando uma View atualizável é modificada, as alterações são refletidas na(s) tabela(s) base.",
                    "Qualquer View pode ser usada para modificar os dados da tabela base.",
                    "Modificar dados através de uma View cria uma cópia dos dados, não alterando a tabela original.",
                    "Para atualizar uma View, é necessário usar um comando especial `UPDATE VIEW` em vez de `UPDATE`."
                ],
                correctAnswer: 0,
                rationale: "Se uma View for 'atualizável' (geralmente views simples, sem junções complexas ou agregações), qualquer comando DML (INSERT, UPDATE, DELETE) executado nela é repassado diretamente para a tabela original (tabela base) de onde os dados vêm."
            },
            {
                question: "Como uma Função Armazenada é tipicamente invocada em SQL?",
                options: [
                    "Usando o comando `EXECUTE nome_funcao(parametros);`",
                    "Como parte de uma expressão em uma instrução SQL, como `SELECT nome_funcao(coluna) FROM tabela;`",
                    "Automaticamente quando um evento DML ocorre em uma tabela.",
                    "Usando o comando `RUN FUNCTION nome_funcao;`"
                ],
                correctAnswer: 1,
                rationale: "Funções são feitas para serem usadas dentro de outras instruções SQL, assim como funções nativas (SUM(), COUNT(), UPPER()). O comando `EXECUTE` é para procedimentos."
            },
            {
                question: "Um parâmetro de um Procedimento Armazenado definido como `OUT` serve para quê?",
                options: [
                    "Para passar um valor de entrada para o procedimento.",
                    "Para permitir que o procedimento retorne um valor para quem o chamou.",
                    "Para passar um valor de entrada que também pode ser modificado e retornado.",
                    "Para indicar que o parâmetro é opcional."
                ],
                correctAnswer: 1,
                rationale: "Parâmetros `OUT` (ou `OUTPUT`) são a forma principal de um procedimento 'retornar' dados para a aplicação ou script que o invocou. O valor é atribuído ao parâmetro dentro do procedimento e pode ser lido após sua execução."
            },
            {
                question: "Qual é um risco potencial ao usar Triggers de forma excessiva?",
                options: [
                    "Aumento da segurança do banco de dados.",
                    "Violação da integridade referencial dos dados.",
                    "Lógica de negócio 'escondida' и dificuldade de depuração.",
                    "Impossibilidade de executar transações complexas."
                ],
                correctAnswer: 2,
                rationale: "Como os triggers disparam automaticamente, a lógica de negócio pode se tornar 'invisível' ou 'escondida'. Isso dificulta a depuração, pois uma simples instrução INSERT pode causar uma cascata de ações que não são óbvias ao analisar o código da aplicação."
            },
            {
                question: "Deseja-se criar um objeto no banco que restrinja o acesso de um usuário para que ele veja apenas o nome e o telefone de clientes de uma cidade específica. Qual objeto é o mais indicado?",
                options: [
                    "Um Trigger na tabela de clientes.",
                    "Um Procedimento Armazenado que recebe a cidade como parâmetro.",
                    "Uma View com uma cláusula `WHERE` que filtra pela cidade desejada.",
                    "Uma Função Armazenada que retorna uma tabela."
                ],
                correctAnswer: 2,
                rationale: "Views são a ferramenta perfeita para segurança baseada em dados. Você cria a View que filtra as linhas e colunas desejadas e, em seguida, concede permissão de acesso à View para o usuário, em vez de conceder acesso direto à tabela completa."
            }
        ];

        const quizContainer = document.getElementById('quiz-container');
        const submitBtn = document.getElementById('submit-btn');
        const resultsContainer = document.getElementById('results-container');
        const scoreEl = document.getElementById('score');
        const summaryEl = document.getElementById('summary');
        const detailedResultsEl = document.getElementById('detailed-results');
        const retryBtn = document.getElementById('retry-btn');

        function loadQuiz() {
            // Limpa o estado anterior
            quizContainer.innerHTML = '';
            resultsContainer.classList.add('hidden');
            document.getElementById('quiz-header').classList.remove('hidden');
            document.getElementById('submit-section').classList.remove('hidden');

            // Cria e insere as perguntas no HTML
            quizData.forEach((currentQuiz, index) => {
                const questionDiv = document.createElement('div');
                questionDiv.classList.add('mb-8', 'p-6', 'border', 'border-gray-200', 'rounded-lg');
                
                const optionsHtml = currentQuiz.options.map((option, optionIndex) => `
                    <label class="flex items-center p-3 my-2 rounded-lg border border-gray-300 cursor-pointer hover:bg-indigo-50 transition-colors duration-200">
                        <input type="radio" name="question${index}" value="${optionIndex}" class="h-5 w-5 text-indigo-600 focus:ring-indigo-500 border-gray-300">
                        <span class="ml-4 text-gray-700">${option}</span>
                    </label>
                `).join('');

                questionDiv.innerHTML = `
                    <p class="text-lg font-semibold mb-4">${index + 1}. ${currentQuiz.question}</p>
                    <div class="space-y-2">${optionsHtml}</div>
                `;
                quizContainer.appendChild(questionDiv);
            });
        }

        function showResults() {
            let score = 0;
            let resultsHtml = '';

            quizData.forEach((currentQuiz, index) => {
                const answerInputs = document.getElementsByName(`question${index}`);
                let userAnswer = -1;
                
                answerInputs.forEach(input => {
                    if (input.checked) {
                        userAnswer = parseInt(input.value);
                    }
                });
                
                const isCorrect = userAnswer === currentQuiz.correctAnswer;
                if (isCorrect) {
                    score++;
                }

                resultsHtml += `
                    <div class="border rounded-lg p-5 ${isCorrect ? 'bg-green-50 border-green-300' : 'bg-red-50 border-red-300'}">
                        <p class="font-semibold text-gray-800">${index + 1}. ${currentQuiz.question}</p>
                        <p class="mt-3 text-sm font-medium ${isCorrect ? 'text-green-800' : 'text-red-800'}">
                            Sua resposta: <span class="font-normal">${userAnswer !== -1 ? currentQuiz.options[userAnswer] : 'Nenhuma resposta selecionada'}</span>
                        </p>
                        ${!isCorrect ? `
                        <div class="mt-3 pt-3 border-t ${isCorrect ? 'border-green-200' : 'border-red-200'}">
                            <p class="text-sm font-medium text-gray-700">
                                Resposta correta: <span class="font-bold text-green-700">${currentQuiz.options[currentQuiz.correctAnswer]}</span>
                            </p>
                            <p class="mt-2 text-xs text-gray-600">
                                <span class="font-semibold">Justificativa:</span> ${currentQuiz.rationale}
                            </p>
                        </div>
                        ` : ''}
                    </div>
                `;
            });
            
            // Oculta o quiz e mostra os resultados
            document.getElementById('quiz-header').classList.add('hidden');
            document.getElementById('submit-section').classList.add('hidden');
            quizContainer.innerHTML = '';
            resultsContainer.classList.remove('hidden');

            // Define a cor da pontuação
            let scoreColor = 'text-green-600';
            if (score < quizData.length * 0.5) scoreColor = 'text-red-600';
            else if (score < quizData.length * 0.8) scoreColor = 'text-yellow-600';

            scoreEl.className = `text-4xl font-extrabold text-center my-4 ${scoreColor}`;
            scoreEl.innerText = `${score} / ${quizData.length}`;
            summaryEl.innerText = `Você acertou ${score} de ${quizData.length} perguntas.`;
            detailedResultsEl.innerHTML = resultsHtml;
        }

        submitBtn.addEventListener('click', showResults);
        retryBtn.addEventListener('click', loadQuiz);

        // Carrega o quiz quando a página é aberta
        loadQuiz();

    </script>
</body>
</html>